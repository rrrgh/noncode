int firstArg;
if (args.length > 0) {
    try {
        firstArg = Integer.parseInt(args[0]);
    } catch (NumberFormatException e) {
        System.err.println("Argument" + args[0] + " must be an integer.");
        System.exit(1);
    }
}

#DI IoC
http://www.vogella.com/tutorials/DependencyInjection/article.html
Dependency injection is a concept valid for any programming language. The general concept behind dependency injection is called Inversion of Control. According to this concept a class should not configure its dependencies statically but should be configured from the outside.

A Java class has a dependency on another class, if it uses an instance of this class. We call this a _class dependency. For example, a class which accesses a logger service has a dependency on this service class.

Ideally Java classes should be as independent as possible from other Java classes. This increases the possibility of reusing these classes and to be able to test them independently from other classes.

If the Java class creates an instance of another class via the new operator, it cannot be used (and tested) independently from this class and this is called a hard dependency. The following example shows a class which has no hard dependencies.

package com.example.e4.rcp.todo.parts;

import java.util.logging.Logger;

public class MyClass {

        private final static Logger logger;

        public MyClass(Logger logger) {
                this.logger = logger;
                // write an info log message
                logger.info("This is a log message.")
        }
}

#Please note that this class is just a normal Java class, there is nothing special about it, except that it avoids direct object creation.

A framework class, usually called the dependency container, could analyze the dependencies of this class. With this analysis it is able to create an instance of the class and inject the objects into the defined dependencies, via Java reflection.

This way the Java class has no hard dependencies, which means it does not rely on an instance of a certain class. This allows you to testyour class in isolation, for example by using mock objects.

Mock objects (mocks) are objects which behave similar as the real object. But these mocks are not programmed; they are configured to behave in a certain predefined way. Mock is an English word which means to mimic or to imitate.

If dependency injection is used, a Java class can be tested in isolation.
1.2. Using annotations to describe class dependencies

Different approaches exist to describe the dependencies of a class. The most common approach is to use Java annotations to describe the dependencies directly in the class.

The standard Java annotations for describing the dependencies of a class are defined in the Java Specification Request 330 (JSR330). This specification describes the @Inject and @Named annotations.

The following listing shows a class which uses annotations to describe its dependencies.

// import statements left out

public class MyPart {

        @Inject private Logger logger;

        // inject class for database access
        @Inject private DatabaseAccessClass dao;

        @Inject
        public void createControls(Composite parent) {
                logger.info("UI will start to build");
                Label label = new Label(parent, SWT.NONE);
                label.setText("Eclipse 4");
                Text text = new Text(parent, SWT.NONE);
                text.setText(dao.getNumber());
        }

}

#Please note that this class uses the new operator for the user interface components. This implies that this part of the code is nothing you plan to replace via your tests. In this case you made the decision to have a hard coupling to the corresponding user interface toolkit.
1.3. Where can objects be injected into a class according to JSR330?

Dependency injection can be performed on:

    the constructor of the class (construction injection)

    a field (field injection)

    the parameters of a method (method injection)

It is possible to use dependency injection on static and on non-static fields and methods. Avoiding dependency injection on static fields and methods is a good practice, as it has the following restrictions and can be hard to debug.

    Static fields will be injected after the first object of the class was created via DI, which means no access to the static field in the constructor

    Static fields can not be marked as final, otherwise the compiler or the application complains at runtime about them

    Static methods are called only once after the first instance of the class was created

1.4. Order in which dependency injection is performed on a class

According to JSR330 the injection is done in the following order:

    constructor injection

    field injection

    method injection

The order in which the methods or fields annotated with @Inject are called is not defined by JSR330. You cannot assume that the methods or fields are called in the order of their declaration in the class.
	As fields and method parameters are injected after the constructor is called, you cannot use injected member variables in the constructor.
2. Java and dependency injection frameworks

You can use dependency injection without any additional framework by providing classes with sufficient constructors or getter and setter methods.

A dependency injection framework simplifies the initialization of the classes with the correct objects.

Two popular dependency injection frameworks are Spring and Google Guice.

The usage of the Spring framework for dependency injection is described in Dependency Injection with the Spring Framework - Tutorial.

#Dependency Injection, Annotations, and why Java is Better Than you Think it is
https://www.objc.io/issues/11-android/dependency-injection-in-java/
My beef was not original or well thought out, but here are my issues, roughly:
    It’s verbose. There’s no shortened syntax for implementing callbacks, like blocks or lambdas, so you have to write a lot of boilerplate to implement even a simple interface. If you need an object that holds four things, you have to create a class with four named fields.
    It’s rigid. Writing sensible Java constantly requires you to specify exactly which exception you’re catching, to specify which type you’re taking in, to check and make sure that your references aren’t null, and to import every class you need to use. And while there is some flexibility at runtime, it’s nowhere close to what you get in the Objective-C runtime, much less something like Ruby or Python.

That was essentially my view of Java. It was this kind of Java:

public class NumberStack {
    List<Integer> mNumbers = new ArrayList<Integer>();

    public void pushNumber(int number) {
        mNumbers.add(number);
    }

    public Integer popNumber() {
        if (mNumber.size() == 0) {
            return null;
        } else {
            return mNumber.remove(mNumber.size() - 1);
        }
    }
}

Add some inner classes and interfaces to the mix, and that is what I learned and worked with. Not the worst thing in the world to be writing, but other languages had features and flexibility that I wished that I had in Java. Never did I find myself writing code in another language and saying, “Man, I wish this were more like Java.”

My opinion has changed.
Something Peculiar to Java

Oddly enough, the tool that changed my mind is only popular because of problems that are peculiar to Java. Consider the following code:

public class Payroll {
    ...

    public long getWithholding(long payInDollars) {
        ...
        return withholding;
   }

    public long getAfterTaxPay(Employee employee) {
        long basePay = EmployeeDatabase.getInstance()
           .getBasePay(employee);
        long withholding = getWithholding(basePay);

        return basePay - withholding;
    }
}

This class has a dependency in getAfterTaxPay() called EmployeeDatabase. There are a variety of ways that we could create this object, but in this example, I’ve used a typical singleton pattern of having a static getInstance method.

Dependencies in Java are surprisingly strict things. Whenever I write a line of code like this:

        long basePay = EmployeeDatabase.getInstance()
           .getBasePay(employee);

I create a strict dependency on the EmployeeDatabase class. Not only that, but I also create a strict dependency on a particular method in EmployeeDatabase: the getInstance() method. In other languages, I might be able to swizzle or monkey patch this kind of thing. Not that that’s a great idea, necessarily, but it is at least possible. Not so in Java.

Other ways of creating a dependency are even more strict than that. Let’s say that instead, I wrote that line like this:

        long basePay = new EmployeeDatabase()
           .getBasePay(employee);

When I use the new keyword, I tie myself down in all the same ways I did with the static method, but I also add one more: calling new EmployeeDatabase() must always yield an instance of the EmployeeDatabase class. You can’t rewrite that constructor to return a mock subclass, no matter what you do.
Dependency Injection

The way we usually solve this problem is to use a technique called dependency injection. It’s not a technique unique to Java, but because of the aforementioned issues, Java is in particularly dire need of it.

Dependency injection simply means receiving collaborators as constructor parameters instead of fetching them ourselves. So Payroll would look like this instead:

public class Payroll {
    ...

    EmployeeDatabase mEmployeeDatabase;

    public Payroll(EmployeeDatabase employeeDatabase) {
        mEmployeeDatabase = employeeDatabase;
    }

    public long getWithholding(long payInDollars) {
        ...
        return withholding;
   }

    public long getAfterTaxPay(Employee employee) {
        long basePay = mEmployeeDatabase.getBasePay(employee);
        long withholding = getWithholding(basePay);

        return basePay - withholding;
    }
}

Is EmployeeDatabase a singleton? A mocked-out subclass? A context-specific implementation? Payroll no longer needs to know.
Declarative Dependency Programming

All of that is just background for what I really want to talk about: dependency injectors.

(An aside: I know it’s a little odd to be two problems deep before actually discussing something nifty, but I hope you’ll bear with me. Understanding what Java gets right just requires more work than it does with other languages. It’s the nature of the beast.)

See, now that we are passing in dependencies through our constructors, our objects are more difficult to use and more difficult to change. Before I used dependency injection, I could use Payroll like this:

    new Payroll().getAfterTaxPay(employee);

Now, though, I have to write this:

    new Payroll(EmployeeDatabase.getInstance())
        .getAfterTaxPay(employee);

Plus, anytime I change Payroll’s dependencies, I have to change every place I write new Payroll, too.

A dependency injector allows me to forget about writing code to explicitly supply dependencies. Instead, I declaratively say what my dependencies are, and the tool worries about supplying them when they’re needed. There are a variety of dependency injection tools out there; for these examples, I’ll be using RoboGuice.

To do this, we use Java’s tool for describing code: the annotation. We declare our dependencies by simply annotating our constructor:

    @Inject
    public Payroll(EmployeeDatabase employeeDatabase) {
        mEmployeeDatabase = employeeDatabase;
    }

The @Inject annotation says, “To build an instance of Payroll, execute this constructor, passing in values for all of its parameters.” Then when I actually need a Payroll instance, I ask the dependency injector to build me one, like so:

    Payroll payroll = RoboGuice.getInjector(getContext())
        .getInstance(Payroll.class);

    long afterTaxPay = payroll.getAfterTaxPay(employee);

Once I’m constructing instances in this way, I can use the injector itself to configure how dependencies are satisfied. Do I want EmployeeDatabase to be a singleton? Do I want to use a customized subclass? All of this can be specified in one place.
The Wider World of Declarative Java

It’s an easily described tool, but it’s hard to overestimate how fundamental the gap is between Java with and without a dependency injector. Without a dependency injector, aggressive refactoring and test-driven development are laborious. With one, they are effortless. The only thing more indispensable to a Java developer than a dependency injector is a good IDE.

Still, it’s just the first taste of a wider set of possibilities. Most of the exciting new stuff for Android developers originating outside Google revolves around annotation-based APIs.

Take ButterKnife, for example. We spend a lot of time in Android wiring up listeners to view objects, like this:

public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_content);

    View okButton = findViewById(R.id.ok_button);
    okButton.setOnClickListener(new View.OnClickListener() {
        public void onClick(View v) {
            onOkButtonClicked();
        }
    });
}

public void onOkButtonClicked() {
    // handle button click
}

ButterKnife allows us to instead provide a little bit of metadata that says, “Call onOkButtonClicked when the view with the id R.id.ok_button is clicked.” Like this:

public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_content);

    ButterKnife.inject(this);
}

@OnClick(R.id.ok_button);
public void onOkButtonClicked() {
    // handle button click
}

I could go on and on with more examples. There are libraries that use annotations to serialize and deserialize JSON, to stash fields in savedInstanceState, to generate code to interface with RESTful web services, and on and on and on.
Compile Time vs. Runtime Annotation Processing

While some tools may achieve similar effects with annotations, Java allows them to achieve these effects in different ways. Take RoboGuice and Dagger, for example. Both are dependency injectors; both use the @Inject annotation. But where RoboGuice reads your code annotations at runtime, Dagger reads them at compile time and generates code.

This has a few important benefits. It means that errors in your annotation semantics can be detected early. Dagger can tell you at compile time when you have a circular dependency; RoboGuice cannot.

It can also improve performance. Generated code can reduce startup time and eliminate the need to read annotations at runtime. Reading annotations requires the use of Java’s reflection APIs, which can be expensive on some Android devices.
An Example of Runtime Annotation Processing

I’d like to finish up by showing a simple example of how one might define and process a runtime annotation. Let’s say that you were an exceptionally impatient person and were tired of typing out fully qualified static constants in your Android codebase, constants like these:

public class CrimeActivity {
    public static final String ACTION_VIEW_CRIME = 
        “com.bignerdranch.android.criminalintent.CrimeActivity.ACTION_VIEW_CRIME”;
}

You could use a runtime annotation to do this work for you. First, you’d create the annotation class:

@Retention(RetentionPolicy.RUNTIME)
@Target( { ElementType.FIELD })
public @interface ServiceConstant { }

This code declares an annotation named ServiceConstant. The code is itself annotated with two annotations: @Retention, and @Target. @Retention says how long the annotation will stick around. Here, we say that we want to see it at runtime. If we wanted this annotation to be processed at compile time only, we could have specified RetentionPolicy.SOURCE.

The other annotation, @Target, says where you can put the annotation in your source code. Any number of values can be provided. Our annotation is only valid for fields, so we have just provided ElementType.FIELD.

Once the annotation is defined, we write some code to look for it and populate the annotated field automatically:

public static void populateConstants(Class<?> klass) {
    String packageName = klass.getPackage().getName();
    for (Field field : klass.getDeclaredFields()) {
        if (Modifier.isStatic(field.getModifiers()) && 
                field.isAnnotationPresent(ServiceConstant.class)) {
            String value = packageName + "." + field.getName();
            try {
                field.set(null, value);
                Log.i(TAG, "Setup service constant: " + value + "");
            } catch (IllegalAccessException iae) {
                Log.e(TAG, "Unable to setup constant for field " + 
                        field.getName() +
                        " in class " + klass.getName());
            }
        }
    }
}

Finally, we add the annotation to our code, and call our magic method:

public class CrimeActivity {
    @ServiceConstant
    public static final String ACTION_VIEW_CRIME;

    static {
        ServiceUtils.populateConstants(CrimeActivity.class);
    }
}

Conclusion:
Well, that’s all I’ve got. So much for annotations in Java. I can’t say that I’m sure that all this has made you feel the same way as I do about Java, but I hope that you’ve seen some interesting stuff. While day-to-day Java may be lacking a bit in expressivity, there are a few basic building blocks in the Java kit that make it possible for advanced developers to create powerful tools that amplify the productivity of the entire community.
If you’re interested in diving in deeper, you will find the topic of driving code generation with annotations very interesting. It’s not necessarily pretty to read or write, but folks are doing some nifty work out there with the tools as they are. The source for ButterKnife is reasonably simple, if you’re interested in an example of how it’s done in the real world.


java.lang.Object
  extended by java.text.Format
      extended by java.text.DateFormat
          extended by java.text.SimpleDateFormat

Date and Time Pattern 	Result
"yyyy.MM.dd G 'at' HH:mm:ss z" 	2001.07.04 AD at 12:08:56 PDT
"EEE, MMM d, ''yy" 	Wed, Jul 4, '01
"h:mm a" 	12:08 PM
"hh 'o''clock' a, zzzz" 	12 o'clock PM, Pacific Daylight Time
"K:mm a, z" 	0:08 PM, PDT
"yyyyy.MMMMM.dd GGG hh:mm aaa" 	02001.July.04 AD 12:08 PM
"EEE, d MMM yyyy HH:mm:ss Z" 	Wed, 4 Jul 2001 12:08:56 -0700
"yyMMddHHmmssZ" 	010704120856-0700
"yyyy-MM-dd'T'HH:mm:ss.SSSZ" 	2001-07-04T12:08:56.235-0700

#Java Print string literal unicode as the actual character
for (int i=0x2500;i<=0x257F;i++) {
  System.out.printf("0x%x : %c\n",i,(char)i);
}

for(int index=0;index<65536; index++)
System.out.prinln((char)index);
But you can not view the unicode chars above 256. They will be displayed as question mark.
Instead you write all unicode characters in a file using UTF8 format.

#Convert International String to \u Codes in java
http://stackoverflow.com/questions/6230190/convert-international-string-to-u-codes-in-java

#Printing out unicode from Java code issue in windows console
http://stackoverflow.com/questions/20386335/printing-out-unicode-from-java-code-issue-in-windows-console
In additions to the steps you have taken, you also need a PrintStream/PrintWriter that encodes the printed characters to UTF-8.
Unfortunately, Java designers have chosen to open the standard streams with the so called "default" encoding, which is almost always unusable*) under Windows. Hence, using System.out and System.err naively will make your program output appear differently, depending on where you run it. This is straight against the goal: compile once, run anywhere.

*) It will be some non standard "code page" nobody except Microsoft recognizes on this planet. And AFAIK, if for example you have a German keyboard and a "German" OEM Windows and you want to have date and time in your home time zone, there is just no way to say: But I want UTF-8 input/output in my CMD window. This is one reason why I have my dual Ubuntu booted most of the time, where it goes without saying that the terminal does UTF-8.

The following usually works for me in JDK7:
public static PrintWriter stdout = new PrintWriter(
    new OutputStreamWriter(System.out, StandardCharsets.UTF_8), true);
For ancient Java versions, I replace StandardCharsets.UTF_8 by Charset.forName("UTF-8").

#Chinese Characters Displayed as Questions Marks in Mac Terminal
http://stackoverflow.com/questions/15488628/chinese-characters-displayed-as-questions-marks-in-mac-terminal/15516722#15516722
System.out printstream isn't created as a UTF-8 print stream. You can convert it to be one like this:
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;

public class JavaTest {
    public static void main(String[] args) {
        try{
            PrintStream out = new PrintStream(System.out, true, "UTF-8");

            out.println("Hello");
            out.println("施华洛世奇");
            out.println("World");
        }
        catch(UnsupportedEncodingException UEE){
	//...
        }
    }
}

You can also set the default encoding as per here by:
java -Dfile.encoding=UTF-8 -jar JavaTest.jar

#Gnu Make Makefile Examples
http://www.jwrr.com/content/Gnu-Makefile-Examples/

#Using make and writing Makefiles
https://www.cs.swarthmore.edu/~newhall/unixhelp/howto_makefiles.html

:read !"date +'%Y-%m-%d %H:%M:%S.%N %:::z'"
:read !date +'%Y-%m-%d %H:%M:%S.%N %:::z'
:read `date +'%Y-%m-%d %H:%M:%S.%N %:::z`

#Java String encoding conversion UTF-8 to SHIFT-JIS
stringToEncode.getBytes(Charset.forName("SHIFT-JIS"))
or
new String(unecodedString.getBytes("SHIFT-JIS"), "UTF-8")

Very strange,as:

byte[] b = resultString.getBytes("Shift_JIS");
String value = new String(b, "UTF-8");

didn't work, but:

String value = new String(resultString.getBytes("SHIFT-JIS"), "UTF-8")

Works like a charm. Maybe it was because of the underscore and lower case character in "Shift_JIS".

#jar
jar cf jar-file input-file(s)
As an example, suppose you wanted to put audio files and gif images used by the TicTacToe demo into a JAR file, and that you wanted all the files to be on the top level, with no directory hierarchy. You could accomplish that by issuing this command from the parent directory of the images and audio directories:
jar cf ImageAudio.jar -C images . -C audio .
The -C images part of this command directs the Jar tool to go to the images directory, and the . following -C images directs the Jar tool to archive all the contents of that directory. The -C audio . part of the command then does the same with the audio directory.

http://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html
https://cristos.vipserv.org/2015/03/a-crash-course-in-gnu-debugger-a-gdb-tutorial/
How to change the value of a local or global variable in gdb?

Acceptance Test Driven Development (ATDD)
Test Driven Development (TDD)
Behavior Driven Develpment (BDD)

#Java String UTF-8 SHIFT-JIS
http://stackoverflow.com/questions/37155417/string-encoding-conversion-utf-8-to-shift-jis/

